<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 迷宮挑戰賽 - 完整自定義版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #0f172a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
            max-height: 90vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.2) transparent;
        }
        .ui-overlay::-webkit-scrollbar { width: 4px; }
        .ui-overlay::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }
        .ui-overlay > * { pointer-events: auto; }
        .control-panel {
            background: rgba(255, 255, 255, 0.96);
            backdrop-filter: blur(12px);
            padding: 1.25rem;
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
            width: 340px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        .select-input {
            @apply w-full border-2 border-slate-200 rounded-lg px-2 py-1 text-sm outline-none focus:border-blue-500 bg-white;
        }
        .btn-action { @apply flex-1 text-white py-2 rounded-xl font-bold transition-all shadow-md active:scale-95 disabled:opacity-50; }
        .img-pick-btn { @apply border-2 rounded-lg p-1 transition-all; }
        .img-pick-btn.active { @apply border-blue-500 bg-blue-50; }
        .img-pick-btn:not(.active) { @apply border-transparent hover:bg-slate-100; }
    </style>
</head>
<body class="w-screen h-screen">

    <div class="ui-overlay flex flex-col gap-4">
        <div class="control-panel flex flex-col gap-3">
            <h1 class="text-2xl font-black text-slate-800 tracking-tight">AI 迷宮：生存進化</h1>
            
            <!-- 迷宮尺寸與敵人 -->
            <div class="grid grid-cols-2 gap-3">
                <div>
                    <label class="text-[10px] font-bold text-slate-400 uppercase">寬度 (建議奇數)</label>
                    <input type="number" id="mazeW" value="51" class="select-input">
                </div>
                <div>
                    <label class="text-[10px] font-bold text-slate-400 uppercase">高度 (建議奇數)</label>
                    <input type="number" id="mazeH" value="51" class="select-input">
                </div>
            </div>
            <div>
                <label class="text-[10px] font-bold text-slate-400 uppercase">敵人數量</label>
                <input type="number" id="enemyCount" value="15" class="select-input">
            </div>

            <!-- 角色外觀詳細設置 -->
            <div class="border-t border-slate-100 pt-2 flex flex-col gap-2">
                <h2 class="text-xs font-black text-slate-500 uppercase tracking-widest">角色外觀設置</h2>
                
                <div>
                    <label class="text-[10px] font-bold text-slate-400 uppercase">模式</label>
                    <select id="charMode" class="select-input">
                        <option value="image">圖片模式</option>
                        <option value="shape">形狀模式</option>
                    </select>
                </div>

                <!-- 圖片選擇區 -->
                <div id="imageArea" class="flex flex-col gap-2">
                    <label class="text-[10px] font-bold text-slate-400 uppercase">選擇頭像</label>
                    <div class="flex gap-2">
                        <button class="img-pick-btn active" data-url="https://lh3.googleusercontent.com/a/ACg8ocIACThLQv2z6bs3wAc0ecYIEd-4zdOb0IbkOZV-ZVyRKsblTmw=s288-c-no">
                            <img src="https://lh3.googleusercontent.com/a/ACg8ocIACThLQv2z6bs3wAc0ecYIEd-4zdOb0IbkOZV-ZVyRKsblTmw=s288-c-no" class="w-10 h-10 rounded-md">
                        </button>
                        <button class="img-pick-btn" data-url="icon.png">
                            <img src="icon.png" class="w-10 h-10 rounded-md" onerror="this.src='https://img.icons8.com/color/512/capybara.png'">
                        </button>
                    </div>
                </div>

                <!-- 形狀選擇區 -->
                <div id="shapeArea" class="hidden flex flex-col gap-2">
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label class="text-[10px] font-bold text-slate-400 uppercase">種類</label>
                            <select id="shapeKind" class="select-input">
                                <option value="circle">球體</option>
                                <option value="square">方塊</option>
                                <option value="triangle">三角形</option>
                                <option value="polygon">五邊形</option>
                            </select>
                        </div>
                        <div>
                            <label class="text-[10px] font-bold text-slate-400 uppercase">顏色</label>
                            <input type="color" id="shapeColor" value="#6366f1" class="w-full h-8 rounded border-2 border-slate-200 cursor-pointer">
                        </div>
                    </div>
                </div>
            </div>

            <!-- AI 設置 -->
            <div class="border-t border-slate-100 pt-2 flex flex-col gap-1">
                <div class="flex items-center justify-between">
                    <span class="text-sm font-bold text-slate-700">無敵 AI 避險導航</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="aiToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-slate-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                </div>
                <div>
                    <label class="text-[10px] font-bold text-slate-400 uppercase">AI 移動速度 (左快右慢)</label>
                    <input type="range" id="aiSpeed" min="0.02" max="0.6" step="0.02" value="0.1" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <!-- 控制按鈕 -->
            <div class="flex flex-col gap-2 border-t border-slate-100 pt-3">
                <div class="flex gap-2">
                    <button id="startBtn" class="bg-indigo-600 hover:bg-indigo-700 btn-action shadow-indigo-200">開始遊戲</button>
                    <button id="stopBtn" class="bg-slate-500 hover:bg-slate-600 btn-action shadow-slate-200">停止</button>
                </div>
                <div class="flex gap-2">
                    <button id="pauseBtn" class="bg-amber-500 hover:bg-amber-600 btn-action shadow-amber-200">暫停</button>
                    <button id="retrackBtn" class="bg-emerald-500 hover:bg-emerald-600 btn-action shadow-emerald-200 hidden">追蹤主角</button>
                </div>
            </div>
        </div>

        <div id="statusMessage" class="px-6 py-3 rounded-2xl font-black text-center bg-white shadow-2xl opacity-0 transition-all scale-90"></div>
    </div>

    <canvas id="mazeCanvas"></canvas>

    <footer class="fixed bottom-4 w-full text-center text-slate-400 text-xs pointer-events-none">
        <div class="pointer-events-auto bg-slate-900/70 inline-block px-4 py-1.5 rounded-full backdrop-blur-md border border-slate-700 shadow-lg">
            版權所有 © 2026 <a href="https://pandapanda6666.github.io" class="text-blue-400 hover:underline">PandaPanda的AI日常</a> All Rights Reserved.
        </div>
    </footer>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');

        // UI 元件
        const inputW = document.getElementById('mazeW');
        const inputH = document.getElementById('mazeH');
        const inputE = document.getElementById('enemyCount');
        const charModeSelect = document.getElementById('charMode');
        const imageArea = document.getElementById('imageArea');
        const shapeArea = document.getElementById('shapeArea');
        const shapeKindSelect = document.getElementById('shapeKind');
        const shapeColorInput = document.getElementById('shapeColor');
        const aiToggle = document.getElementById('aiToggle');
        const aiSpeedInput = document.getElementById('aiSpeed');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const retrackBtn = document.getElementById('retrackBtn');
        const statusMsg = document.getElementById('statusMessage');
        const imgBtns = document.querySelectorAll('.img-pick-btn');

        // 資源載入
        const playerImg = new Image();
        let isImgLoaded = false;
        playerImg.onload = () => isImgLoaded = true;
        playerImg.onerror = () => isImgLoaded = false;

        // 遊戲狀態
        let grid = [];
        let rows, cols;
        const cellSize = 40;
        let isGameOver = false;
        let isPaused = false;
        let isGameRunning = false;
        let lastTime = 0;
        let aiTickTimer = 0;
        let animationId = null;

        let currentSkin = {
            mode: 'image',
            shape: 'circle',
            color: '#6366f1',
            imgUrl: 'https://lh3.googleusercontent.com/a/ACg8ocIACThLQv2z6bs3wAc0ecYIEd-4zdOb0IbkOZV-ZVyRKsblTmw=s288-c-no'
        };

        class Entity {
            constructor(x, y, speed) {
                this.gridX = x; this.gridY = y;
                this.realX = x * cellSize; this.realY = y * cellSize;
                this.speed = speed;
                this.targetX = x; this.targetY = y;
            }
            update(dt) {
                const tx = this.targetX * cellSize, ty = this.targetY * cellSize;
                const dx = tx - this.realX, dy = ty - this.realY;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d > 0.5) {
                    const step = this.speed * cellSize * dt;
                    this.realX += (dx/d) * Math.min(step, d);
                    this.realY += (dy/d) * Math.min(step, d);
                    return false;
                }
                this.realX = tx; this.realY = ty;
                this.gridX = this.targetX; this.gridY = this.targetY;
                return true;
            }
        }

        let player, goal, enemies = [];
        let camera = { x: 0, y: 0, zoom: 0.8, isFollowing: true };
        let isDragging = false;
        let lastMousePos = { x: 0, y: 0 };
        const WALL = 1, PATH = 0;

        // UI 事件
        charModeSelect.addEventListener('change', (e) => {
            currentSkin.mode = e.target.value;
            imageArea.classList.toggle('hidden', currentSkin.mode !== 'image');
            shapeArea.classList.toggle('hidden', currentSkin.mode !== 'shape');
        });

        imgBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                imgBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSkin.imgUrl = btn.getAttribute('data-url');
                playerImg.src = currentSkin.imgUrl;
            });
        });

        function initGame() {
            if (animationId) cancelAnimationFrame(animationId);
            isGameRunning = true; isGameOver = false; isPaused = false;
            pauseBtn.textContent = "暫停";
            statusMsg.style.opacity = "0";
            retrackBtn.classList.add('hidden');
            
            // 套用造型設定
            currentSkin.shape = shapeKindSelect.value;
            currentSkin.color = shapeColorInput.value;
            if (currentSkin.mode === 'image') playerImg.src = currentSkin.imgUrl;

            cols = Math.max(5, parseInt(inputW.value) || 21);
            rows = Math.max(5, parseInt(inputH.value) || 21);
            if (cols % 2 === 0) cols++; if (rows % 2 === 0) rows++;
            
            generateMazeIterative();
            addExtraPaths();
            
            player = new Entity(1, 1, 7.5);
            goal = { x: cols - 2, y: rows - 2 };
            
            enemies = [];
            const eCount = Math.max(0, parseInt(inputE.value) || 0);
            let attempts = 0;
            while (enemies.length < eCount && attempts < 10000) {
                let rx = Math.floor(Math.random()*cols), ry = Math.floor(Math.random()*rows);
                if (grid[ry][rx] === PATH && (Math.abs(rx-1)+Math.abs(ry-1) > 12)) {
                    if (!enemies.some(e => e.gridX === rx && e.gridY === ry)) {
                        enemies.push(new Entity(rx, ry, 4.2));
                    }
                }
                attempts++;
            }
            
            camera.isFollowing = true;
            camera.x = player.realX + cellSize/2;
            camera.y = player.realY + cellSize/2;
            
            resizeCanvas();
            lastTime = performance.now();
            animationId = requestAnimationFrame(mainLoop);
        }

        function generateMazeIterative() {
            grid = Array(rows).fill().map(() => Array(cols).fill(WALL));
            let stack = [{x:1, y:1}]; grid[1][1] = PATH;
            while (stack.length > 0) {
                let curr = stack[stack.length - 1];
                let neighbors = [];
                [[0,-2],[0,2],[-2,0],[2,0]].forEach(([dx, dy]) => {
                    let nx = curr.x+dx, ny = curr.y+dy;
                    if (nx>0 && nx<cols-1 && ny>0 && ny<rows-1 && grid[ny][nx] === WALL) {
                        neighbors.push({x:nx, y:ny, mx:curr.x+dx/2, my:curr.y+dy/2});
                    }
                });
                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random()*neighbors.length)];
                    grid[next.my][next.mx] = PATH; grid[next.y][next.x] = PATH;
                    stack.push(next);
                } else stack.pop();
            }
        }

        function addExtraPaths() {
            const extra = Math.floor(rows * cols * 0.15);
            for (let i = 0; i < extra; i++) {
                let rx = Math.floor(Math.random()*(cols-2))+1;
                let ry = Math.floor(Math.random()*(rows-2))+1;
                grid[ry][rx] = PATH;
            }
        }

        function findPath(start, end, avoidEnemies = false) {
            const openSet = [{ x: start.x, y: start.y, g: 0, f: 0, parent: null }];
            const closedSet = new Set();
            const heuristic = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            // 大地圖動態搜尋上限
            const maxIter = Math.max(10000, rows * cols * 2);
            let iter = 0;

            const enemySpots = new Set();
            if (avoidEnemies) {
                enemies.forEach(e => {
                    enemySpots.add(`${e.gridX},${e.gridY}`);
                    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx, dy]) => enemySpots.add(`${e.gridX+dx},${e.gridY+dy}`));
                });
            }

            while (openSet.length > 0 && iter < maxIter) {
                iter++;
                openSet.sort((a, b) => a.f - b.f);
                const curr = openSet.shift();
                if (curr.x === end.x && curr.y === end.y) {
                    let res = [], t = curr;
                    while (t) { res.push({x:t.x, y:t.y}); t = t.parent; }
                    return res.reverse();
                }
                closedSet.add(`${curr.x},${curr.y}`);
                [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx, dy]) => {
                    let nx = curr.x + dx, ny = curr.y + dy;
                    if (nx<0||nx>=cols||ny<0||ny>=rows||grid[ny][nx]===WALL||closedSet.has(`${nx},${ny}`)) return;
                    if (avoidEnemies && enemySpots.has(`${nx},${ny}`)) return;
                    let g = curr.g + 1;
                    let ex = openSet.find(o => o.x === nx && o.y === ny);
                    if (!ex) openSet.push({x:nx, y:ny, g:g, f:g+heuristic({x:nx,y:ny},end), parent:curr});
                    else if (g < ex.g) { ex.g=g; ex.f=g+heuristic({x:nx,y:ny},end); ex.parent=curr; }
                });
            }
            if (avoidEnemies) return findPath(start, end, false);
            return null;
        }

        function mainLoop(timestamp) {
            if (!isGameRunning) return;
            if (isGameOver) { draw(); return; }
            const dt = Math.min(0.1, (timestamp - lastTime) / 1000);
            lastTime = timestamp;

            if (!isPaused) {
                if (aiToggle.checked && player.gridX === player.targetX && player.gridY === player.targetY) {
                    aiTickTimer += dt;
                    if (aiTickTimer >= parseFloat(aiSpeedInput.value)) {
                        aiTickTimer = 0;
                        const p = findPath({x: player.gridX, y: player.gridY}, goal, true);
                        if (p && p.length > 1) { player.targetX = p[1].x; player.targetY = p[1].y; }
                    }
                }
                player.update(dt);
                if (player.gridX === goal.x && player.gridY === goal.y) gameOver("任務完成！順利抵達終點！", "text-emerald-600");

                enemies.forEach(e => {
                    if (e.update(dt)) {
                        const dist = Math.abs(e.gridX - player.gridX) + Math.abs(e.gridY - player.gridY);
                        if (dist < 15) {
                            const p = findPath({x:e.gridX, y:e.gridY}, {x:player.gridX, y:player.gridY});
                            if (p && p.length > 1) { e.targetX = p[1].x; e.targetY = p[1].y; }
                        } else {
                            const dirs = [[0,1],[0,-1],[1,0],[-1,0]].sort(()=>Math.random()-0.5);
                            for(let [dx,dy] of dirs) {
                                if(grid[e.gridY+dy]?.[e.gridX+dx] === PATH) { e.targetX = e.gridX+dx; e.targetY = e.gridY+dy; break; }
                            }
                        }
                    }
                    const hit = Math.sqrt(Math.pow(e.realX-player.realX,2)+Math.pow(e.realY-player.realY,2));
                    if (hit < cellSize*0.65) gameOver("失敗：你被敵人捕獲了！", "text-red-600");
                });
            }
            draw();
            animationId = requestAnimationFrame(mainLoop);
        }

        function drawPlayer(x, y, radius) {
            if (currentSkin.mode === 'image') {
                if (isImgLoaded) {
                    ctx.save(); ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.clip();
                    ctx.drawImage(playerImg, x - radius, y - radius, radius * 2, radius * 2); ctx.restore();
                    ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.stroke();
                } else {
                    ctx.fillStyle = "#3b82f6"; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
                }
            } else {
                ctx.fillStyle = currentSkin.color; ctx.strokeStyle = "white"; ctx.lineWidth = 3;
                const r = radius;
                ctx.beginPath();
                switch (currentSkin.shape) {
                    case 'circle': ctx.arc(x, y, r, 0, Math.PI * 2); break;
                    case 'square': ctx.rect(x - r, y - r, r * 2, r * 2); break;
                    case 'triangle': ctx.moveTo(x, y - r); ctx.lineTo(x + r, y + r); ctx.lineTo(x - r, y + r); ctx.closePath(); break;
                    case 'polygon': 
                        for (let i = 0; i < 5; i++) {
                            const a = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                            ctx.lineTo(x + r * Math.cos(a), y + r * Math.sin(a));
                        }
                        ctx.closePath(); break;
                }
                ctx.fill(); ctx.stroke();
            }
        }

        function draw() {
            if (camera.isFollowing && !isGameOver) {
                camera.x += (player.realX + cellSize/2 - camera.x) * 0.12;
                camera.y += (player.realY + cellSize/2 - camera.y) * 0.12;
            }
            ctx.fillStyle = "#0f172a"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            // 視窗裁切優化
            const vL = camera.x - (canvas.width/2)/camera.zoom, vR = camera.x + (canvas.width/2)/camera.zoom;
            const vT = camera.y - (canvas.height/2)/camera.zoom, vB = camera.y + (canvas.height/2)/camera.zoom;
            const sX = Math.max(0, Math.floor(vL/cellSize)), eX = Math.min(cols-1, Math.ceil(vR/cellSize));
            const sY = Math.max(0, Math.floor(vT/cellSize)), eY = Math.min(rows-1, Math.ceil(vB/cellSize));

            for (let y = sY; y <= eY; y++) {
                for (let x = sX; x <= eX; x++) {
                    ctx.fillStyle = grid[y][x] === WALL ? "#1e293b" : "#f8fafc";
                    ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
                }
            }

            // 終點
            ctx.fillStyle = "#10b981"; ctx.beginPath();
            ctx.arc((goal.x+0.5)*cellSize, (goal.y+0.5)*cellSize, cellSize*0.4, 0, Math.PI*2); ctx.fill();

            // 敵人
            enemies.forEach(e => {
                ctx.fillStyle = "#ef4444"; ctx.beginPath();
                ctx.arc(e.realX+cellSize/2, e.realY+cellSize/2, cellSize*0.35, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.4)"; ctx.lineWidth = 1; ctx.stroke();
            });

            drawPlayer(player.realX + cellSize/2, player.realY + cellSize/2, cellSize*0.45);
            ctx.restore();
        }

        function gameOver(msg, cls) {
            isGameOver = true;
            statusMsg.textContent = msg;
            statusMsg.className = `px-6 py-3 rounded-2xl font-black text-center bg-white shadow-2xl transition-all scale-100 ${cls}`;
            statusMsg.style.opacity = "1";
        }

        startBtn.addEventListener('click', initGame);
        stopBtn.addEventListener('click', () => { 
            isGameRunning = false; 
            if (animationId) cancelAnimationFrame(animationId);
            ctx.clearRect(0,0,canvas.width,canvas.height); 
            statusMsg.style.opacity = "0"; 
        });
        pauseBtn.addEventListener('click', () => { if(!isGameRunning || isGameOver) return; isPaused = !isPaused; pauseBtn.textContent = isPaused ? "繼續" : "暫停"; });

        window.addEventListener('keydown', (e) => {
            if (!isGameRunning || isPaused || isGameOver || aiToggle.checked) return;
            if (player.gridX === player.targetX && player.gridY === player.targetY) {
                let dx=0, dy=0;
                if (e.key==='ArrowUp') dy=-1; if (e.key==='ArrowDown') dy=1;
                if (e.key==='ArrowLeft') dx=-1; if (e.key==='ArrowRight') dx=1;
                if (dx!==0 || dy!==0) {
                    if (grid[player.gridY+dy]?.[player.gridX+dx] === PATH) { player.targetX = player.gridX+dx; player.targetY = player.gridY+dy; }
                    e.preventDefault();
                }
            }
        });

        canvas.addEventListener('mousedown', e => { isDragging=true; lastMousePos={x:e.clientX, y:e.clientY}; camera.isFollowing=false; retrackBtn.classList.remove('hidden'); });
        window.addEventListener('mousemove', e => { if(isDragging){ camera.x-=(e.clientX-lastMousePos.x)/camera.zoom; camera.y-=(e.clientY-lastMousePos.y)/camera.zoom; lastMousePos={x:e.clientX, y:e.clientY}; }});
        window.addEventListener('mouseup', () => isDragging=false);
        canvas.addEventListener('wheel', e => { e.preventDefault(); camera.zoom = Math.min(10, Math.max(0.1, camera.zoom * (e.deltaY>0?0.85:1.15))); }, {passive:false});
        retrackBtn.addEventListener('click', () => { camera.isFollowing=true; retrackBtn.classList.add('hidden'); });
        function resizeCanvas() { canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
